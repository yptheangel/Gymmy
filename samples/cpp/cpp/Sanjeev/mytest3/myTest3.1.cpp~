/*
* File:   myTest.cpp
* Author: Sanjeev
*
* Created on 3 JANUARY, 2017, 9:57 AM
*/

#include <unistd.h>
#include <iostream>
#include <string>
#include <sstream>
#include <stdio.h>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/video.hpp>

using namespace cv;
using namespace std;

// Init threshold values
int thresh = 100;
int max_thresh = 255;
RNG rng(12345);

// Define contours and hierarchy for point validation
typedef std::vector<std::vector<cv::Point> > Contours;
typedef std::vector<cv::Vec4i> Hierarchy;
Contours contours;
Hierarchy hierarchy;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard

Scalar colorB = Scalar(255, 0, 0);
Scalar colorG = Scalar(0, 255, 0);
Scalar colorR = Scalar(0, 0, 255);

void processVideo();
string ToString(double val);

////////////////////////////////////////////////////////////////////////////////////////////////////////
int main( int argc, char** argv ){

    while (true)
    {
	//create GUI windows (In Order)
    	namedWindow("Frame");
	namedWindow("Blurred");
    	namedWindow("FG Mask MOG 2");
	namedWindow("Canny");
	namedWindow("Contour");
	//namedWindow("test");

    	//create Background Subtractor objects
    	pMOG2 = createBackgroundSubtractorMOG2(10, 16, false); //MOG2 approach
        processVideo();
	
	// User action buttons
        if (waitKey(30) == 27){ //wait for 'esc' key press for 30ms. Breaks loop
            cout << "esc key is pressed by user" << endl;
            break;
       } 

    }

   return 0;

}
////////////////////////////////////////////////////////////////////////////////////////////////////////

void processVideo() {
	Mat blur; // blurred frame

    //create the capture object
    VideoCapture capture(0);
	capture.read(frame);

    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    while( keyboard != 'q' && keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
	// Blur background
	GaussianBlur(frame, blur, Size(17,17), 0, 0);

        //update the background model
        pMOG2->apply(blur, fgMaskMOG2);

	// Canny image
	Mat cannyNew;
	Canny( fgMaskMOG2, cannyNew, 75, 200, 5 );

        //get the frame number and write it on the original frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20), cv::Scalar(255,255,255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
	//get the frame number and write it on the original frame
	
	//vector<vector<Point> > contours;
  	//vector<Vec4i> hierarchy;

	findContours( cannyNew, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_NONE, Point(0, 0) ); //
	vector<vector<Point> > contours_poly( contours.size() );

	vector<Rect> boundRect( contours.size() );
  	vector<Point2f>center( contours.size() );
	vector<float>radius( contours.size() );

	Mat drawing = Mat::zeros( cannyNew.size(), CV_8UC3 ); //

  	for( size_t i = 0; i< contours.size(); i++ ) {
		approxPolyDP( Mat(contours[i]), contours_poly[i], 2, true );
       		//minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );
				
		double a = contourArea(contours[i], false);
		boundRect[i] = boundingRect( Mat(contours_poly[i]) );
		double b = boundRect[i].width;
		double c = boundRect[i].height;
		double area_rect = b*c;

		// && a >= 600 && a < 7000
		if(contours[i].size() >= 600 && a >= 150 && b < 250 && b >= c + 60 && c >= 60 && c <= 130 && c < 175 && area_rect >= 13000 && area_rect < 40000){
			//bool top_left_box = false;
			//bool bot_left_box = false;
			bool top_right_box = false;
			//bool bot_right_box = false;
		
			drawContours( drawing, contours, (int)i, colorB, 2, 8, hierarchy, 0, Point() );

			for(int t = b/3; t < b ; t++){
				for(int s=0; s < c/3 ; s++){
					if(drawing.at<Vec3b>(Point(boundRect[i].tl().x + t,boundRect[i].tl().y + s)).val[0] == 255){
						top_right_box = true;
					}			
				}		    		
			}
			
			
			if(top_right_box == false){
				drawing = Mat::zeros( drawing.size(), CV_8UC3 );
			}else{
				
				rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), colorG, 1, 8, 0 );

				imwrite( "Image.jpg", drawing );
			
				cout << "Area of contour: " + ToString(a) << endl;
				cout << "Width: " + ToString(b) + " Height: " + ToString(c) << endl;
				cout << "Area of Rectangle: " + ToString(area_rect)  << endl;
			}
		}
     	}
	
	/*
	Mat test = Mat::zeros( cannyNew.size(), CV_8UC1 );
	
	for(int i=6; i<cannyNew.rows; i++){
    		for(int j=6; j<cannyNew.cols; j++){
			if(cannyNew.at<uchar>(Point(j-1, i-1)) == 255){
				test.at<uchar>(Point(j, i)) = 255;
			}
		}	
	}
	*/

        //show the current frame and the fg masks
        imshow("Frame", frame);
	imshow("Blurred", blur);
        imshow("FG Mask MOG 2", fgMaskMOG2);
	imshow("Canny", cannyNew);
	imshow("Contour", drawing);
	//imshow("test", test);

        //get the input from the keyboard
        keyboard = (char)waitKey( 30 );
    }
    //delete capture object
    capture.release();
}

// Convert double to string
string ToString(double val){
    stringstream stream;
    stream << val;
    return stream.str();
}


