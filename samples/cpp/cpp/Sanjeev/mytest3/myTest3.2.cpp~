
/*
* File:   myTest.cpp
* Author: Sanjeev
*
* Created on 3 JANUARY, 2017, 9:57 AM
*/

#include <unistd.h>
#include <iostream>
#include <string>
#include <sstream>
#include <stdio.h>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/video.hpp>

using namespace cv;
using namespace std;

// Init integer
int counter = 0;

// Init boolean
bool isAboveLine = false; 

// Init point
Point prevCenter; 
Point c1;
Point c2;

// Define contours and hierarchy for Contour Creation
typedef std::vector<std::vector<cv::Point> > Contours;
typedef std::vector<cv::Vec4i> Hierarchy;
Contours contours;
Hierarchy hierarchy;

Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

char keyboard; //input from keyboard

// Define colors
Scalar colorB = Scalar(255, 0, 0);
Scalar colorG = Scalar(0, 255, 0);
Scalar colorR = Scalar(0, 0, 255);

// Function definitions
void processVideo();
string ToString(double val);
void checkIfCrossedLine(Point &center);

////////////////////////////////////////////////////////////////////////////////////////////////////////
int main( int argc, char** argv ){

    while (true)
    {
	/*create GUI windows (In Order)*/
    	namedWindow("Frame");
	namedWindow("Blurred");
    	namedWindow("FG Mask MOG 2");
	namedWindow("Canny");
	namedWindow("Contour");

    	//create Background Subtractor objects
    	pMOG2 = createBackgroundSubtractorMOG2(10, 16, false); //MOG2 approach
//        pMOG2 = createBackgroundSubtractorMOG2(20, 16, false); //MOG2 approach
        
	processVideo(); // function to  process video
	
	// User action buttons
        if (waitKey(30) == 27){ //wait for 'esc' key press for 30ms. Breaks loop
            cout << "esc key is pressed by user" << endl;
            break;
       } 
	
    }

   return 0;

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Function to process video feed
void processVideo() {

	// Init Frames
	Mat frame; //Original frame
	Mat blur; // frame to store blurred image
	Mat fgMaskMOG2; //fg mask generated by MOG2 method
	Mat cannyNew; // frame used to store edge detected contours


	//create the capture object and place it into "frame" of type Mat
	VideoCapture capture(0);
	capture.read(frame);

	//read input data. ESC or 'q' for quitting
	keyboard = 0;
    while( keyboard != 'q' && keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
	// read input data. ESC or 'q' for quitting


	// Blur background
	GaussianBlur(frame, blur, Size(17,17), 0, 0);

	// Draw a threshold line on original image
  	line( frame, Point( 0, 240 ), Point( 640, 240), Scalar( 0, 255, 255 ),  2, 8 );

	//get the frame number and write it on the original frame
        //stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(170,30), cv::Scalar(255,255,255), -1);
        //ss << capture.get(CAP_PROP_POS_FRAMES);
        string disp = "Counter: " + ToString(counter);
        putText(frame, disp.c_str(), cv::Point(15, 25), FONT_HERSHEY_SIMPLEX, 0.75 , cv::Scalar(153, 50, 204));
	//get the frame number and write it on the original frame

        //update the background model using background image subtraction
        pMOG2->apply(blur, fgMaskMOG2);

	// Performing edge detection on moving objects
	Canny( fgMaskMOG2, cannyNew, 75, 200, 5 );

        // From edge detection image, find contours (continuous lines only)
	findContours( cannyNew, contours, hierarchy, cv::RETR_LIST, CV_CHAIN_APPROX_SIMPLE, Point() ); 

	
	// Find the convex hull object for each contour
   	vector<vector<Point> >hull( contours.size() );
	vector<vector<Vec4i> > convDef(contours.size() );


   	for( int i = 0; i < contours.size(); i++ ){  
		convexHull( Mat(contours[i]), hull[i], false ); 
	}
		
	// Init contour poly approximation
	vector<vector<Point> > contours_poly( contours.size() );

	// Init bounding rectangle and center and radius for circle drawn
	vector<Rect> boundRect( contours.size() );
  	vector<Point2f>center( contours.size() );
	vector<float>radius( contours.size() );

	// Init an empty matrix  with the same size as cannyNew
	Mat drawing = Mat::zeros( cannyNew.size(), CV_8UC3 ); 

	/* for loop to keep running as contours are found */
  	for( size_t i = 0; i< contours.size(); i++ ) {
		approxPolyDP( Mat(contours[i]), contours_poly[i], 4, true ); // Approximates contour as a third degree polynomial and plots points into contours_poly
       		//minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] ); // Draws smallest circle around contours_poly detected
       		
				
		double size = contours[i].size(); // get size of each contour
		//double len = arcLength(contours[i], true); // get length of contour array
		double a = contourArea(contours[i], false); // get contour area

		boundRect[i] = boundingRect( Mat(contours_poly[i]) ); // generate bounding rectangle around contours_poly
		double b = boundRect[i].width; // get bounding rectangle width
		double c = boundRect[i].height; // get bounding rectangle height
		double area_rect = b*c; // get area of bounding rectangle

		double d = contourArea(hull[i], true); // get area of convex hull
		double hull_size = hull[i].size(); // get size of convex hull array

		/* if loop to detect objects which are dumbbell shaped and draw contours around them */
		//  
		if( area_rect >= 15000 && area_rect < 40000 && b >= c + 50 && b < 250 && d > 0.57*area_rect && hull_size > 14 && size > 100){
			
			/* Drawing contours */
			drawContours( drawing, contours, (int)i, colorB, 2, 8, hierarchy, 0, Point() ); // draw contour on Mat: drawing
			drawContours( drawing, hull, (int)i, colorR, 1, 8, vector<Vec4i>(), 0, Point() ); // draw convex hull onto "drawing"
			//drawContours( frame, contours_poly, (int)i, colorG, 6,8, vector<Vec4i>(), 0, Point() ); // draw contours_poly onto original image "frame"
			
			/* Output hull area and hull array size to terminal window */
			cout << "Hull Size: " + ToString(hull_size) << endl;
			cout << "Hull Area: " + ToString(d) << endl;
			cout << "" << endl;
			
			/* Draw circles of convex hull points on "drawing" and output convex hull points to terminal window 
			(method not required but just used in case values are needed later on) */
			int ct = 0;
			int lg_curve_counter = 0; // Initialise large curve counter
			for(int t=0; t < hull_size; t++){
				cout << hull[i][t] << endl;
				if((hull[i][t].x <= hull[i][t+1].x + 10 && hull[i][t].x >= hull[i][t+1].x - 10) && (hull[i][t].y <= hull[i][t+1].y + 10 && hull[i][t].y >= hull[i][t+1].y - 10)){
					//circle(drawing, Point(hull[i][t]), 5, colorG, -1, 8, 0);					
					ct++;
					if(ct > 3){
						circle(drawing, Point(hull[i][t]), 5, colorG, -1, 8, 0);
						
					}
					if(ct == 3){
						lg_curve_counter++; // increment large curve counter 
					}
				}else{
					circle(drawing, Point(hull[i][t]), 5, colorR, 1, 8, 0);
					ct = 0;					
				}
				if(ct >= 3){
					circle(drawing, Point(hull[i][t]), 5, colorG, -1, 8, 0);
					circle(drawing, Point(hull[i][t-1]), 5, colorG, -1, 8, 0);
					circle(drawing, Point(hull[i][t-2]), 5, colorG, -1, 8, 0);
				}
				
			}
			
			/* Init center position and draws a circle around it (used to determine when dumbbell has crossed line) */
			Point center(boundRect[i].tl().x + b/2, boundRect[i].tl().y + c - 5);
			//circle( frame, center, 3, Scalar(0,0,255), -1, 8, 0 );

			/* Logic method for determining each count (direction and region based) */
			if(prevCenter != Point(0)){
				if(prevCenter.y > center.y && center.y < 240 && !isAboveLine && lg_curve_counter >= 2){
					isAboveLine = true;
					++counter;
				}
				checkIfCrossedLine(center);			
			}
			prevCenter = center; // make previous center position the new center position

			/* Draw rectangles */
			rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), colorG, 1, 8, 0 ); // Draw rectangle on "drawing" where contour is found
			//rectangle( frame, boundRect[i].tl(), boundRect[i].br(), colorG, 1, 8, 0 ); // Draw rectangle on "frame" where contour is found
			
			/* Write Mat to image files */
			imwrite( "5.Image_final.jpg", drawing );
			imwrite( "4.Image_canny.jpg", cannyNew );
			imwrite( "3.Image_fgMaskMOG2.jpg", fgMaskMOG2 );
			imwrite( "2.Image_blur.jpg", blur );
			imwrite( "1.Image_original.jpg", frame );
			
			/* Write data to terminal */
			cout << "" << endl;
			//cout << "Length of closed contour: " + ToString(len) << endl;
			cout << "Size of contour: " + ToString(size) << endl;
			cout << "Area of contour: " + ToString(a) << endl;
			cout << "Width: " + ToString(b) + " Height: " + ToString(c) << endl;
			cout << "Area of Rectangle: " + ToString(area_rect)  << endl;
			cout << "No. of Big Curves: " + ToString(lg_curve_counter)  << endl;
			cout << "" << endl;
		}
     	}

        /* show selected frames */
        imshow("Frame", frame);
	imshow("Blurred", blur);
        imshow("FG Mask MOG 2", fgMaskMOG2);
	imshow("Canny", cannyNew);
	imshow("Contour", drawing);
	//imshow("HSV", hsv);

	/*  User action buttons */
        if (waitKey(30) == 27){ //wait for 'esc' key press for 30ms. Breaks loop
            cout << "esc key is pressed by user" << endl;
            break;
       } else if (waitKey(30) == 32){ // wait for 'spacebar' to be pressed for 30ms. Resets count
		counter = 0;
		cout << "counter restarted" << endl;
	}
	
    }
    /* delete capture object */
    capture.release();
}

// Convert double to string
string ToString(double val){
    stringstream stream;
    stream << val;
    return stream.str();
}

// Modifies boolean value isAboveLine to prevent multiple counts
void checkIfCrossedLine(Point &center){
	float y = center.y;
	if(y > 240){
		isAboveLine = false;
	}
}



